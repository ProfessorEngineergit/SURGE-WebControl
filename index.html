<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SURGE‑WebControl</title>

    <!-- Nasalization Font -->
    <link href="https://fonts.cdnfonts.com/css/nasalization" rel="stylesheet" />
    <style>
      @font-face {
        font-family: "Nasalization";
        src: url("https://cdn.jsdelivr.net/gh/ejoliet/nasalization/nasalization-rg.woff2") format("woff2"),
             url("https://cdn.jsdelivr.net/gh/ejoliet/nasalization/nasalization-rg.woff")  format("woff");
        font-display: swap;
      }
    </style>

    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha512-bugHuflTqEZZ2uRiKqdF6RxQ9WG/jc2LGJtIDiCGk4BmSL7xIuiKdVhK1hO6Jp5ablZGjDVqdDriLetr7vV0Lg==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <style>
      :root {
        --matrix: #24fff4;
        --glow  : #ffffff;
        --speed-gray: rgba(255,255,255,0.28);
        --speed-red : #ff4040;
      }

      html,body{margin:0;height:100%;background:#000;color:#fff;font-family:"Nasalization",sans-serif;overflow:hidden;-webkit-font-smoothing:antialiased}
      
      body::before {
          content: "";
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 15vh; 
          background: linear-gradient(to bottom, 
              rgba(0,0,0,1) 0%,    
              rgba(0,0,0,0.9) 50%, 
              rgba(0,0,0,0) 100%   
          );
          z-index: 1; 
          pointer-events: none; 
      }

      .glow{color:#fff;text-shadow:0 0 8px var(--glow),0 0 20px var(--glow)}
      
      #matrixCanvas{
          position: fixed;
          inset: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          z-index: 0; 
      }
      .glass{backdrop-filter:blur(22px)saturate(180%);-webkit-backdrop-filter:blur(22px)saturate(180%);background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.28);border-radius:28px;box-shadow:0 8px 28px rgba(0,0,0,.45)}
      
      #top-window{
          position:fixed;
          top:8vh;
          left:50%;
          transform:translateX(-50%);
          width:clamp(240px,70%,680px);
          padding:18px 32px;
          text-align:center;
          z-index:10; 
      }
      #top-window h1{margin:0;font-size:clamp(1.4rem,4vw,2.8rem)}
      
      #controls-window{
          position:fixed;
          bottom: 9vh; 
          left:50%;
          transform:translateX(-50%);
          width:clamp(330px, 85%, 550px); 
          padding: 15px clamp(25px, 6vw, 40px); 
          display:flex;
          justify-content:space-between; 
          align-items:center;
          gap:clamp(15px, 3vw, 30px);
          z-index:10; 
      }
      
      .joystick-ring{
        position:relative;
        flex:0 0 clamp(220px,40vw,320px); 
        aspect-ratio:1;
        border-radius:50%;
        display:flex;
        align-items:center;
        justify-content:center
      }
      .joystick-ring::before{content:"";position:absolute;inset:0;border-radius:50%;background:inherit;backdrop-filter:inherit;-webkit-backdrop-filter:inherit;box-shadow:0 8px 28px rgba(0,0,0,.45)}
      .joystick{position:relative;width:64%;aspect-ratio:1;border-radius:50%;touch-action:none;} 
      .stick{--size:70%;width:var(--size);height:var(--size);background:var(--glow);border-radius:50%;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);touch-action:none;box-shadow:0 0 20px 8px var(--glow);transition:transform .05s linear}
      
      #speedbar{
        position:relative;
        display:inline-block; 
        touch-action: none; /* Wichtig für Slider-Touch-Interaktion */
      }
      .speed-block{
        border-radius:6px;background:var(--speed-gray);transition:background .15s;
        transform-origin: bottom left; 
      }
      .speed-block.active{background:var(--speed-red)}
      #speed-thumb{position:absolute;width:6px;height:28px;background:#bbb;border-radius:3px;transition:transform .15s;transform-origin: center center; touch-action: none;}
      #drag-arrow{position:absolute;font-size:14px;color:#aaa;animation:bounce 1.2s infinite ease-in-out;transform-origin:center bottom; display: none;}
      @keyframes bounce{0%,100%{transform:translate(-50%, -50%) translateY(0) scaleY(1)}50%{transform:translate(-50%, -50%) translateY(-8px) scaleY(1.3)}}
    </style>
  </head>
  <body>
    <canvas id="matrixCanvas"></canvas>
    <div id="top-window" class="glass"><h1 class="glow">SURGE‑WebControl</h1></div>
    <div id="controls-window" class="glass">
      <div id="speedbar"></div>
      <div class="joystick-ring glass">
        <div class="joystick" id="right-joystick"><div class="stick" id="right-stick"></div></div>
      </div>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded',()=>{
        const speedBar = document.getElementById('speedbar');
        const thumb    = document.createElement('div'); thumb.id='speed-thumb'; speedBar.appendChild(thumb);
        const arrow    = document.createElement('div'); arrow.id='drag-arrow'; arrow.textContent='▲'; speedBar.appendChild(arrow);

        const blocks=[]; 
        
        const baseNumVerticalBlocks = 12; 
        const secondarySize = 24; 
        
        const numVerticalBlocks = Math.floor(baseNumVerticalBlocks / 2); 
        const size = secondarySize * 2.5; 
        const numHorizontalBlocks = 0; 

        const allBlockData = [];

        const verticalBlocksX_local = 0; 
        let currentVerticalY_cssBottom = 0; 

        for (let i = 0; i < numVerticalBlocks; i++) {
            allBlockData.push({
                x: verticalBlocksX_local,
                y: currentVerticalY_cssBottom,
                rot: 0,
                w: size,          
                h: secondarySize  
            });
            currentVerticalY_cssBottom += secondarySize; 
        }
        
        let minOverallX = Infinity, minOverallY = Infinity;
        let maxOverallX = -Infinity, maxOverallY = -Infinity;

        if (allBlockData.length > 0) { 
            allBlockData.forEach(data => {
                const { x, y, rot, w, h } = data; 
                const rad = rot * Math.PI / 180;
                const cosR = Math.cos(rad);
                const sinR = Math.sin(rad);
                const points = [
                    { xp: x, yp: y }, 
                    { xp: x + w * cosR, yp: y + w * sinR }, 
                    { xp: x - h * sinR, yp: y + h * cosR }, 
                    { xp: x + w * cosR - h * sinR, yp: y + w * sinR + h * cosR }
                ];
                points.forEach(p => {
                    minOverallX = Math.min(minOverallX, p.xp);
                    minOverallY = Math.min(minOverallY, p.yp);
                    maxOverallX = Math.max(maxOverallX, p.xp);
                    maxOverallY = Math.max(maxOverallY, p.yp);
                });
            });
        } else { 
            minOverallX = 0; minOverallY = 0; maxOverallX = 0; maxOverallY = 0;
        }
        
        const finalOffsetX = -minOverallX;
        const finalOffsetY = -minOverallY;

        allBlockData.forEach(data => {
            const b = document.createElement('div');
            b.className = 'speed-block';
            b.style.position = 'absolute';
            b.style.left = (data.x + finalOffsetX) + 'px';
            b.style.bottom = (data.y + finalOffsetY) + 'px';
            b.style.width = data.w + 'px';
            b.style.height = data.h + 'px';
            b.style.transform = `rotate(${data.rot}deg)`;
            b.dataset.rotation = data.rot; 
            speedBar.appendChild(b);
            blocks.push(b); 
        });
        
        if (allBlockData.length > 0) {
            speedBar.style.width = (maxOverallX - minOverallX) + 'px';
            speedBar.style.height = (maxOverallY - minOverallY) + 'px';
        } else {
            speedBar.style.width = '0px';
            speedBar.style.height = '0px';
        }
        
        // --- SLIDER LOGIC ---
        let sliderSnapIndex=-1; 
        let sliderActiveTouchId = null;
        let sliderMouseDragging = false;

        function updateArrowVisibility() {
            if (sliderActiveTouchId === null && !sliderMouseDragging && sliderSnapIndex === 0 && blocks.length > 0) { 
                arrow.style.display = 'block';
            } else {
                arrow.style.display = 'none';
            }
        }

        function sliderSnapTo(index) {
          if (index < 0 || index >= blocks.length) return; 
          sliderSnapIndex = index;
          blocks.forEach((b,idx)=>b.classList.toggle('active',idx<=index));
          updateArrowVisibility();

          const currentBlock = blocks[index];
          const blockRect = currentBlock.getBoundingClientRect();
          const speedBarRect = speedBar.getBoundingClientRect();
          const blockRotation = parseFloat(currentBlock.dataset.rotation) || 0;
          const thumbActualHeight = thumb.offsetHeight; 
          const spacing = 10; 
          let thumbTargetX, thumbTargetY; 

          if (blockRotation === 0) { 
            thumbTargetX = (blockRect.right - speedBarRect.left) + spacing + (thumbActualHeight / 2); 
            thumbTargetY = (blockRect.top - speedBarRect.top) + blockRect.height / 2; 
          } 
          // Anmerkung: thumbAngle wird nicht mehr gesetzt, da der Daumen immer 0 Grad hat
          thumb.style.transform = `translate(calc(${thumbTargetX}px - 50%), calc(${thumbTargetY}px - 50%)) rotate(0deg)`;
          
          if (arrow.style.display === 'block') {
            let arrowX = thumbTargetX; 
            let arrowY = thumbTargetY; 
            const arrowSpacing = 15; 
            if (blockRotation === 0) { 
                arrowX = thumbTargetX; 
                arrowY = thumbTargetY - (thumb.offsetHeight / 2) - arrowSpacing; 
            }
            arrow.style.left = `${arrowX}px`; 
            arrow.style.top = `${arrowY}px`;
          }
        }

        function getClosestBlockIndex(clientX, clientY) {
            if(blocks.length===0) return -1; 
            const blockRects = blocks.map(b => b.getBoundingClientRect());
            let minDistance = Infinity;
            let closestIndex = 0;
            blockRects.forEach((rect, i) => {
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const distance = Math.hypot(clientX - centerX, clientY - centerY);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestIndex = i;
                }
            });
            return closestIndex;
        }
        
        function handleSliderTouchStart(e) {
            if (blocks.length === 0 || sliderActiveTouchId !== null) return;
            // e.preventDefault(); // Wird vom window handler gemacht, falls nötig
            const touch = e.changedTouches[0];
            sliderActiveTouchId = touch.identifier;
            arrow.style.display = 'none';
            const closestIndex = getClosestBlockIndex(touch.clientX, touch.clientY);
            if (closestIndex !== -1 && closestIndex !== sliderSnapIndex) {
                sliderSnapTo(closestIndex);
            }
        }

        function handleSliderMouseDown(e) {
            if (blocks.length === 0) return;
            e.preventDefault();
            sliderMouseDragging = true;
            arrow.style.display = 'none';
            const closestIndex = getClosestBlockIndex(e.clientX, e.clientY);
             if (closestIndex !== -1 && closestIndex !== sliderSnapIndex) {
                sliderSnapTo(closestIndex);
            }
        }
        
        // --- JOYSTICK LOGIC ---
        const joy = document.getElementById('right-joystick'); 
        const stick = document.getElementById('right-stick');  
        let joystickActiveTouchId = null; 
        let joystickMouseDragging = false;

        const getJoystickCenterAndMax = () => {
            const joyRect = joy.getBoundingClientRect(); 
            const stickRect = stick.getBoundingClientRect(); 
            const joyRadius = joyRect.width / 2;
            const stickRadius = stickRect.width / 2;
            const maxDistance = joyRadius + (stickRadius / 3);
            return {
                x: joyRect.left + joyRadius,  
                y: joyRect.top + joyRadius,   
                max: maxDistance
            };
        };

        const moveJoystick = (clientX, clientY) => { 
            const c = getJoystickCenterAndMax();
            let dx = clientX - c.x;
            let dy = clientY - c.y;
            const dist = Math.min(Math.hypot(dx, dy), c.max); 
            const a = Math.atan2(dy, dx);
            dx = dist * Math.cos(a);
            dy = dist * Math.sin(a);
            stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        };
        
        joy.addEventListener('touchstart', e => {
            // e.preventDefault(); // Wird vom window handler gemacht, falls nötig
            if (joystickActiveTouchId === null) {
                const touch = e.changedTouches[0];
                joystickActiveTouchId = touch.identifier; 
                moveJoystick(touch.clientX, touch.clientY); 
            }
        }, { passive: false });
      
        joy.addEventListener('mousedown', e => {
            e.preventDefault();
            joystickMouseDragging = true;
            moveJoystick(e.clientX, e.clientY); 
        });

        // --- GLOBAL EVENT HANDLERS FOR MOVEMENT AND END ---
        window.addEventListener('touchmove', e => {
            let handled = false;
            if (sliderActiveTouchId !== null) {
                for (const touch of e.changedTouches) {
                    if (touch.identifier === sliderActiveTouchId) {
                        const closestIndex = getClosestBlockIndex(touch.clientX, touch.clientY);
                        if (closestIndex !== -1 && closestIndex !== sliderSnapIndex) {
                           sliderSnapTo(closestIndex);
                        }
                        handled = true;
                        break;
                    }
                }
            }
            if (joystickActiveTouchId !== null) {
                for (const touch of e.changedTouches) { 
                    if (touch.identifier === joystickActiveTouchId) { 
                        moveJoystick(touch.clientX, touch.clientY);
                        handled = true;
                        break; 
                    }
                }
            }
            if (handled) {
                e.preventDefault(); // Nur preventDefault, wenn einer unserer Controller den Touch verarbeitet
            }
        }, { passive: false });

        window.addEventListener('mousemove', e => {
            let handled = false;
            if (sliderMouseDragging) {
                const closestIndex = getClosestBlockIndex(e.clientX, e.clientY);
                if (closestIndex !== -1 && closestIndex !== sliderSnapIndex) {
                    sliderSnapTo(closestIndex);
                }
                handled = true;
            }
            if (joystickMouseDragging) { 
                moveJoystick(e.clientX, e.clientY); 
                handled = true;
            }
            if (handled) {
                e.preventDefault();
            }
        });

        function handleGlobalTouchEnd(e) {
            for (const touch of e.changedTouches) {
                if (touch.identifier === sliderActiveTouchId) {
                    sliderActiveTouchId = null;
                    updateArrowVisibility();
                }
                if (touch.identifier === joystickActiveTouchId) { 
                    joystickActiveTouchId = null; 
                    stick.style.transform = 'translate(-50%,-50%)'; 
                }
            }
        }
        window.addEventListener('touchend', handleGlobalTouchEnd);
        window.addEventListener('touchcancel', handleGlobalTouchEnd); 
        
        window.addEventListener('mouseup', () => {
            if (sliderMouseDragging) {
                sliderMouseDragging = false;
                updateArrowVisibility();
            }
            if (joystickMouseDragging) {
                joystickMouseDragging = false;
                stick.style.transform = 'translate(-50%,-50%)';
            }
        });

        // Initialisierung
        if (blocks.length > 0) {
            sliderSnapTo(0); 
        } else { 
            thumb.style.display = 'none'; 
            arrow.style.display = 'none'; 
        }

        /* === DIGITAL RAIN === */
        const canvas=document.getElementById('matrixCanvas');const ctx=canvas.getContext('2d');const FONT=16,SPEED=0.33,FADE=0.05;let cols,drops;function rainInit(){canvas.width=window.innerWidth;canvas.height=window.innerHeight;cols=Math.floor(canvas.width/FONT);drops=Array.from({length:cols},()=>Math.random()*canvas.height/FONT);}rainInit();(function draw(){ctx.fillStyle=`rgba(0,0,0,${FADE})`;ctx.fillRect(0,0,canvas.width,canvas.height);ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--matrix');ctx.font=FONT+'px monospace';for(let i=0;i<cols;i++){const ch=String.fromCharCode(0x30A0+Math.random()*96);const x=i*FONT,y=drops[i]*FONT;ctx.fillText(ch,x,y);drops[i]+=SPEED;if(y>canvas.height&&Math.random()>0.975)drops[i]=0;}requestAnimationFrame(draw);})();window.addEventListener('resize',rainInit);
      });
    </script>
  </body>
</html>
